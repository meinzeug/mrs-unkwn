import {
  detectAIContent,
  evaluateModel,
  submitFeedback,
  retrainModel,
} from '../src/services/homework.service';
import fs from 'fs';
import path from 'path';
import { AddressInfo } from 'net';

async function run() {
  const modelDir = path.resolve(__dirname, '../data');
  const modelFile = path.join(modelDir, 'homework_model.bin');
  const versionFile = path.join(modelDir, 'model_version.json');
  fs.mkdirSync(modelDir, { recursive: true });
  const model = {
    weights: { chatgpt: 2.0, ai: 1.5 },
    bias: -1.0,
    threshold: 0.5,
  };
  fs.writeFileSync(modelFile, JSON.stringify(model));
  fs.writeFileSync(versionFile, JSON.stringify({ version: 1 }));

  const dataset = [
    { text: 'This is a regular homework submission.', label: false },
    { text: 'This text was generated by ChatGPT.', label: true },
    { text: 'Another human-written text.', label: false },
  ];
  const evalResult = await evaluateModel(dataset);
  if (evalResult.accuracy !== 1) {
    throw new Error(`Expected accuracy 1 but got ${evalResult.accuracy}`);
  }

  const feedbackFile = path.join(modelDir, 'homework_feedback.log');
  if (fs.existsSync(feedbackFile)) {
    fs.unlinkSync(feedbackFile);
  }

  await submitFeedback('This text was generated by ChatGPT.', false);
  if (!fs.existsSync(feedbackFile)) {
    throw new Error('Expected feedback log to be created');
  }
  const lines = fs.readFileSync(feedbackFile, 'utf8').trim().split('\n');
  if (lines.length !== 1) {
    throw new Error('Expected one feedback entry');
  }

  const before = JSON.parse(fs.readFileSync(modelFile, 'utf8')).weights.chatgpt;
  const versionBefore = JSON.parse(fs.readFileSync(versionFile, 'utf8')).version;
  await retrainModel();
  const after = JSON.parse(fs.readFileSync(modelFile, 'utf8')).weights.chatgpt;
  const versionAfter = JSON.parse(fs.readFileSync(versionFile, 'utf8')).version;
  if (before === after) {
    throw new Error('Expected model weight to change after retraining');
  }
  if (fs.existsSync(feedbackFile)) {
    throw new Error('Expected feedback log to be removed after retraining');
  }
  if (versionAfter !== versionBefore + 1) {
    throw new Error('Expected model version to increment');
  }

  process.env.DATABASE_URL = 'postgres://user:pass@localhost:5432/test';
  process.env.JWT_SECRET = 'test-secret';
  process.env.JWT_REFRESH_SECRET = 'test-refresh';
  process.env.EMAIL_SERVICE_KEY = 'test-email';
  process.env.NODE_ENV = 'test';

  const { default: app } = await import('../src/index');
  await new Promise<void>((resolve, reject) => {
    const server = app.listen(0, async () => {
      try {
        const port = (server.address() as AddressInfo).port;
        const res = await fetch(`http://localhost:${port}/api/homework/model`);
        const data = await res.json();
        if (data.version !== versionAfter) {
          throw new Error('Expected version from API to match latest version');
        }
        if (typeof data.lastRetrained !== 'string') {
          throw new Error('Expected lastRetrained to be a string');
        }
        server.close();
        resolve();
      } catch (err) {
        server.close();
        reject(err);
      }
    });
  });

  console.log('homework.test.ts passed');
}

run().catch((err) => {
  console.error(err);
  process.exit(1);
});
