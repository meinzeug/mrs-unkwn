import 'dart:async';
import 'package:flutter/foundation.dart';

/// Types of monitoring alerts that can be generated by the system.
enum MonitoringAlertType {
  screenTimeLimitExceeded,
  inappropriateAppUsed,
  deviceTamperingDetected,
}

/// Model representing a single monitoring alert.
class MonitoringAlert {
  MonitoringAlert({
    required this.id,
    required this.type,
    required this.message,
    required this.timestamp,
    this.priority = 0,
    this.handled = false,
  });

  final int id;
  final MonitoringAlertType type;
  final String message;
  final DateTime timestamp;
  final int priority;
  bool handled;
}

/// Service responsible for alert generation, delivery and history tracking.
class MonitoringAlertService {
  MonitoringAlertService();

  final _alerts = <MonitoringAlert>[];
  final _controller = StreamController<MonitoringAlert>.broadcast();

  /// Stream of newly created alerts.
  Stream<MonitoringAlert> get alerts => _controller.stream;

  final Map<MonitoringAlertType, Duration> _cooldowns = {
    MonitoringAlertType.screenTimeLimitExceeded:
        const Duration(minutes: 30),
    MonitoringAlertType.inappropriateAppUsed: const Duration(minutes: 30),
    MonitoringAlertType.deviceTamperingDetected: const Duration(minutes: 30),
  };

  final Map<MonitoringAlertType, DateTime> _lastSent = {};

  final Map<MonitoringAlertType, int> _thresholds = {
    MonitoringAlertType.screenTimeLimitExceeded: 60,
  };

  /// Configure a threshold value for a specific alert [type].
  void setThreshold(MonitoringAlertType type, int value) {
    _thresholds[type] = value;
  }

  /// Configure cooldown for alert [type].
  void setCooldown(MonitoringAlertType type, Duration duration) {
    _cooldowns[type] = duration;
  }

  /// Trigger a new alert if the cooldown has expired.
  Future<void> trigger(
    MonitoringAlertType type, {
    required String message,
    int priority = 0,
  }) async {
    final now = DateTime.now();
    final last = _lastSent[type];
    final cooldown = _cooldowns[type] ?? Duration.zero;
    if (last != null && now.difference(last) < cooldown) {
      return;
    }
    final alert = MonitoringAlert(
      id: _alerts.length + 1,
      type: type,
      message: message,
      timestamp: now,
      priority: priority,
    );
    _alerts.add(alert);
    _lastSent[type] = now;
    _controller.add(alert);
    await deliver(alert);
  }

  /// Deliver the alert to parents. Subclasses can override for testing.
  @protected
  Future<void> deliver(MonitoringAlert alert) async {
    // Placeholder for push, email or SMS delivery.
    // ignore: avoid_print
    print('ALERT [${alert.type.name}] ${alert.message}');
  }

  /// Returns an immutable view of the alert history.
  List<MonitoringAlert> get history => List.unmodifiable(_alerts);

  /// Mark an alert as handled by parents.
  void markHandled(int id) {
    final index = _alerts.indexWhere((a) => a.id == id);
    if (index != -1) {
      _alerts[index].handled = true;
    }
  }

  /// Dispose internal resources.
  void dispose() {
    _controller.close();
  }
}

